@using cima.Listings
@using cima.Permissions
@using Microsoft.AspNetCore.Components.Forms
@using System.IO
@using MudBlazor
@inject IListingAppService ListingService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inherits cimaComponentBase

<div class="space-y-4">
    @* InputFile solo funciona en WebAssembly, no en Server *@
    <InputFile id="@FileInputId"
               OnChange="HandleFileSelection"
               multiple
               accept="image/jpeg,image/jpg,image/png,image/webp"
               class="hidden"
               disabled="@IsUploading" />

    @* Header *@
    <div class="flex items-center justify-between">
        <h3 class="text-lg font-semibold text-neutral-900">
            @L["GalleryManager:Title"]
            @if (Images.Any())
            {
                <span class="ml-2 text-sm font-normal text-neutral-500">@L["GalleryManager:Count", Images.Count]</span>
            }
        </h3>

        <label for="@FileInputId" class="cima-btn cima-btn-primary cima-btn-sm cursor-pointer @(IsUploading ? "opacity-50 pointer-events-none" : "")">
            @if (IsUploading)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>@L["GalleryManager:Uploading"]</span>
            }
            else
            {
                <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" Class="mr-2" />
                <span>@L["GalleryManager:AddImages"]</span>
            }
        </label>
    </div>

    @* Upload Zone *@
    @if (!Images.Any() && !IsUploading)
    {
        <label for="@FileInputId" class="block border-2 border-dashed border-neutral-300 rounded-xl p-8 text-center cursor-pointer hover:border-navy-400 hover:bg-navy-50/50 transition-colors">
            <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Size="Size.Large" Class="text-neutral-400" />
            <p class="mt-4 text-neutral-600">
                <span class="text-navy-600 font-medium">@L["GalleryManager:UploadCta"]</span> @L["GalleryManager:UploadHint"]
            </p>
            <p class="mt-2 text-sm text-neutral-500">@L["GalleryManager:UploadFormats"]</p>
        </label>
    }

    @* Image Grid *@
    @if (Images.Any())
    {
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            @foreach (var (image, index) in Images.Select((img, i) => (img, i)))
            {
                <div class="group relative aspect-square rounded-lg overflow-hidden bg-neutral-100 border border-neutral-200 @(DraggedIndex == index ? "opacity-50" : "") @(index == 0 ? "ring-2 ring-navy-500" : "")"
                     draggable="true"
                     @ondragstart="() => HandleDragStart(index)"
                     @ondragover:preventDefault
                     @ondragover="() => HandleDragOver(index)"
                     @ondrop:preventDefault
                     @ondrop="() => HandleDrop(index)"
                     @ondragend="HandleDragEnd">
                    
                    <img src="@image.Url" alt="@(image.AltText ?? $"Imagen {index + 1}")" class="w-full h-full object-cover" />
                    
                    @if (index == 0)
                    {
                        <div class="absolute top-2 left-2">
                            <MudChip T="string" Size="Size.Small" Color="Color.Primary">@L["GalleryManager:PrimaryBadge"]</MudChip>
                        </div>
                    }
                    
                    <div class="absolute top-2 right-2">
                        <span class="w-6 h-6 flex items-center justify-center text-xs font-medium bg-black/60 text-white rounded-full">@(index + 1)</span>
                    </div>
                    
                    <div class="absolute inset-0 bg-black/0 group-hover:bg-black/40 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100">
                        <div class="flex gap-2">
                            @if (index > 0)
                            {
                                <MudIconButton Icon="@Icons.Material.Filled.FirstPage" Size="Size.Small" 
                                    Color="Color.Default" Variant="Variant.Filled"
                                    OnClick="@(() => MoveToFirst(index))" title="@L["GalleryManager:MoveToFirst"]" aria-label="@L["GalleryManager:MoveToFirst"]" />
                            }
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" 
                                Color="Color.Error" Variant="Variant.Filled"
                                OnClick="@(() => RemoveImage(image))" Disabled="@IsDeleting" title="@L["GalleryManager:Delete"]" aria-label="@L["GalleryManager:Delete"]" />
                        </div>
                    </div>
                    
                    <div class="absolute bottom-2 left-1/2 -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <div class="px-3 py-1 bg-black/60 rounded-full text-white text-xs">@L["GalleryManager:DragHint"]</div>
                    </div>
                </div>
            }
        </div>
        
        <p class="text-sm text-neutral-500 text-center">
            @L["GalleryManager:OrderHelp"]
        </p>
    }

    @* Upload Progress *@
    @if (UploadProgress.Any())
    {
        <div class="space-y-2 bg-neutral-50 rounded-lg p-4">
            <p class="text-sm font-medium text-neutral-700">@L["GalleryManager:UploadingFiles"]</p>
            @foreach (var item in UploadProgress)
            {
                <div class="space-y-1">
                    <div class="flex justify-between text-xs text-neutral-600">
                        <span class="truncate max-w-[200px]">@item.Key</span>
                        <span>@item.Value%</span>
                    </div>
                    <MudProgressLinear Value="@item.Value" Color="Color.Primary" />
                </div>
            }
        </div>
    }
</div>

@code {
    private const string FileInputId = "listing-gallery-file-input";

    [Parameter, EditorRequired]
    public Guid ListingId { get; set; }
    
    [Parameter]
    public List<ListingImageDto>? InitialImages { get; set; }
    
    [Parameter]
    public EventCallback<List<ListingImageDto>> ImagesChanged { get; set; }

    private List<ListingImageDto> Images { get; set; } = new();
    private bool IsUploading { get; set; }
    private bool IsDeleting { get; set; }
    private int? DraggedIndex { get; set; }
    private int? DragOverIndex { get; set; }
    private Dictionary<string, int> UploadProgress { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync(); // Importante: inicializar CurrentUser
        Images = InitialImages?.ToList() ?? new List<ListingImageDto>();
        Images = GetOrderedImages();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (InitialImages != null && !ReferenceEquals(InitialImages, Images))
        {
            Images = InitialImages.ToList();
            Images = GetOrderedImages();
        }
    }

    private List<ListingImageDto> GetOrderedImages()
    {
        if (!Images.Any()) return new List<ListingImageDto>();
        
        var ordered = new List<ListingImageDto>();
        var current = Images.FirstOrDefault(i => i.PreviousImageId == null);
        
        while (current != null && ordered.Count < Images.Count)
        {
            ordered.Add(current);
            current = Images.FirstOrDefault(i => i.PreviousImageId == current.ImageId);
        }
        
        var orphans = Images.Where(i => !ordered.Any(o => o.ImageId == i.ImageId));
        ordered.AddRange(orphans);
        
        return ordered;
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        // Debug: Log que el evento se disparó
        await JSRuntime.InvokeVoidAsync("console.log", "HandleFileSelection disparado");
        
        var files = e.GetMultipleFiles(10);
        await JSRuntime.InvokeVoidAsync("console.log", $"Archivos seleccionados: {files.Count()}");
        
        if (!files.Any())
        {
            await JSRuntime.InvokeVoidAsync("console.warn", "No se seleccionaron archivos");
            Snackbar.Add("No se seleccionaron archivos", Severity.Warning);
            return;
        }

        IsUploading = true;
        UploadProgress.Clear();
        StateHasChanged();

        var successCount = 0;
        var errorCount = 0;

        foreach (var file in files)
        {
            try
            {
                // Validar tamaño
                if (file.Size > 5 * 1024 * 1024)
                {
                    Snackbar.Add(L["GalleryManager:FileTooLarge", file.Name], Severity.Warning);
                    errorCount++;
                    continue;
                }

                // Validar que el archivo no esté vacío
                if (file.Size == 0)
                {
                    Snackbar.Add($"El archivo {file.Name} está vacío", Severity.Warning);
                    errorCount++;
                    continue;
                }

                UploadProgress[file.Name] = 0;
                StateHasChanged();

                await JSRuntime.InvokeVoidAsync("console.log", $"Iniciando lectura de {file.Name}, tamaño: {file.Size} bytes");

                // Leer archivo con método simplificado de Blazor
                byte[] imageData;
                try
                {
                    using var stream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
                    var ms = new MemoryStream();
                    
                    UploadProgress[file.Name] = 10;
                    StateHasChanged();
                    
                    // Copiar stream completo
                    await stream.CopyToAsync(ms);
                    
                    UploadProgress[file.Name] = 50;
                    StateHasChanged();
                    
                    imageData = ms.ToArray();
                    
                    await JSRuntime.InvokeVoidAsync("console.log", $"Archivo leído: {imageData.Length} bytes");
                }
                catch (Exception readEx)
                {
                    await JSRuntime.InvokeVoidAsync("console.error", $"Error leyendo archivo {file.Name}", readEx.ToString());
                    Snackbar.Add($"Error leyendo {file.Name}: {readEx.Message}", Severity.Error);
                    UploadProgress.Remove(file.Name);
                    errorCount++;
                    continue;
                }

                // Verificar que se leyó el archivo
                if (imageData.Length == 0)
                {
                    Snackbar.Add($"El archivo {file.Name} está vacío después de leerlo", Severity.Error);
                    UploadProgress.Remove(file.Name);
                    errorCount++;
                    continue;
                }

                UploadProgress[file.Name] = 60;
                StateHasChanged();

                // Convertir a base64
                var base64 = Convert.ToBase64String(imageData);
                var url = $"data:{file.ContentType};base64,{base64}";
                
                UploadProgress[file.Name] = 70;
                StateHasChanged();
                
                await JSRuntime.InvokeVoidAsync("console.log", $"Base64 generado para {file.Name}, longitud: {base64.Length}");

                // Crear DTO
                var createDto = new CreateListingImageDto
                {
                    Url = url,
                    AltText = GetFileNameWithoutExtension(file.Name),
                    FileSize = file.Size,
                    ContentType = file.ContentType
                };

                // Subir al servidor
                UploadProgress[file.Name] = 80;
                StateHasChanged();
                
                await JSRuntime.InvokeVoidAsync("console.log", $"Enviando imagen al servidor: {file.Name}");
                
                var newImage = await ListingService.AddImageAsync(ListingId, createDto);
                
                await JSRuntime.InvokeVoidAsync("console.log", $"Imagen guardada exitosamente: {file.Name}");
                
                Images.Add(newImage);
                UploadProgress[file.Name] = 100;
                StateHasChanged();
                
                UploadProgress.Remove(file.Name);
                successCount++;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                UploadProgress.Remove(file.Name);
                Snackbar.Add($"Error subiendo {file.Name}: {ex.Message}", Severity.Error);
                await JSRuntime.InvokeVoidAsync("console.error", $"Error uploading {file.Name}", ex.ToString());
                errorCount++;
            }
        }

        // Notificar cambios y mostrar resultado
        if (successCount > 0)
        {
            await NotifyImagesChanged();
            Snackbar.Add(L["GalleryManager:UploadSuccess"], Severity.Success);
        }
        
        if (errorCount > 0)
        {
            Snackbar.Add($"Se encontraron {errorCount} errores durante la carga", Severity.Warning);
        }

        IsUploading = false;
        UploadProgress.Clear();
        StateHasChanged();
    }

    private string GetFileNameWithoutExtension(string fileName)
    {
        var lastDot = fileName.LastIndexOf('.');
        return lastDot > 0 ? fileName.Substring(0, lastDot) : fileName;
    }

    private async Task RemoveImage(ListingImageDto image)
    {
        var result = await DialogService.ShowMessageBox(
            L["GalleryManager:DeleteConfirmTitle"],
            L["GalleryManager:DeleteConfirmMessage"],
            yesText: L["GalleryManager:Delete"], cancelText: L["Common:Cancel"]);
        
        if (result != true) return;

        IsDeleting = true;
        StateHasChanged();

        try
        {
            await ListingService.RemoveImageAsync(ListingId, image.ImageId);
            Images.Remove(image);
            await NotifyImagesChanged();
            Snackbar.Add(L["GalleryManager:DeleteSuccess"], Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add(L["GalleryManager:UploadError", ex.Message], Severity.Error);
        }
        finally
        {
            IsDeleting = false;
            StateHasChanged();
        }
    }

    private async Task MoveToFirst(int currentIndex)
    {
        if (currentIndex <= 0 || currentIndex >= Images.Count) return;

        var image = Images[currentIndex];
        Images.RemoveAt(currentIndex);
        Images.Insert(0, image);
        
        await UpdateImageOrder();
    }

    private void HandleDragStart(int index) => DraggedIndex = index;
    private void HandleDragOver(int index) { if (DraggedIndex.HasValue && DraggedIndex.Value != index) DragOverIndex = index; }
    private void HandleDragEnd() { DraggedIndex = null; DragOverIndex = null; }

    private async Task HandleDrop(int targetIndex)
    {
        if (!DraggedIndex.HasValue || DraggedIndex.Value == targetIndex) 
        {
            DraggedIndex = null;
            DragOverIndex = null;
            return;
        }

        var draggedImage = Images[DraggedIndex.Value];
        Images.RemoveAt(DraggedIndex.Value);
        
        if (targetIndex > DraggedIndex.Value) targetIndex--;
        
        Images.Insert(targetIndex, draggedImage);
        DraggedIndex = null;
        DragOverIndex = null;
        
        await UpdateImageOrder();
    }

    private async Task UpdateImageOrder()
    {
        try
        {
            var orderDtos = Images.Select((img, index) => new UpdateImageOrderDto
            {
                ImageId = img.ImageId,
                DisplayOrder = index
            }).ToList();

            await ListingService.UpdateImagesOrderAsync(ListingId, orderDtos);
            await NotifyImagesChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add(L["GalleryManager:ReorderError", ex.Message], Severity.Error);
            Images = InitialImages?.ToList() ?? new List<ListingImageDto>();
            Images = GetOrderedImages();
        }
    }

    private async Task NotifyImagesChanged()
    {
        if (ImagesChanged.HasDelegate)
            await ImagesChanged.InvokeAsync(Images.ToList());
    }
}

